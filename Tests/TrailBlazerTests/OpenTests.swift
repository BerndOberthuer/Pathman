import XCTest
import SwiftShell
import Foundation
@testable import TrailBlazer

class OpenTests: XCTestCase {

    enum Content {
        case randomBytes(UInt)
        case repeatedBytes(CChar, UInt)
        case string([CChar])
        indirect case files(with: Content)

        static let empty: Content = .randomBytes(0)
    }

    static func create(_ type: PathType, contents: Content) -> String? {
        guard let home = DirectoryPath.home else {
            fatalError("Failed to get home directory")
        }
        let path = (home + "\(UUID()).test")._path

        switch type {
        case .file:
            let output = SwiftShell.run(bash: "touch \(path)")
            guard output.succeeded else { return nil }
            switch contents {
            case .randomBytes(let size):
                if size > 0 {
                    let cmd = SwiftShell.run(bash: "echo -n '\(randomString(length: size))' > \(path)")
                    guard cmd.succeeded else {
                        OpenTests.delete(path: path)
                        return nil
                    }
                }
            case .repeatedBytes(let char, let size):
                var chars: [CChar] = []
                while chars.count < size {
                    chars.append(char)
                }
                let str = chars.withUnsafeBufferPointer { ptr in
                    return String(cString: ptr.baseAddress!, encoding: .ascii)!
                }

                guard SwiftShell.run(bash: "echo \(str) >> \(path)").succeeded else {
                    print("Failed to echo \(str.count) bytes")
                    OpenTests.delete(path: path)
                    return nil
                }
            case .string(let chars):
                let str = chars.withUnsafeBufferPointer { ptr in
                    return String(cString: ptr.baseAddress!, encoding: .ascii)!
                }

                guard SwiftShell.run(bash: "echo \(str) >> \(path)").succeeded else {
                    print("Failed to echo \(str.count) bytes")
                    OpenTests.delete(path: path)
                    return nil
                }
            default:
                OpenTests.delete(path: path)
                return nil
            }

            return path
        case .directory: return path
        default: return nil
        }
    }

    @discardableResult
    static func delete(path: String) -> Bool {
        return SwiftShell.run(bash: "rm -rf \(path)").succeeded
    }

    static func read(_ file: FilePath) -> String {
        return SwiftShell.run(bash: "cat \(file._path)").stdout
    }

    func testOpenFile() {
        var _path: String?
        repeat {
            _path = OpenTests.create(.file, contents: .empty)
        } while (_path == nil)

        let path = _path!
        defer { OpenTests.delete(path: path) }

        guard let file = FilePath(path) else {
            XCTFail("Path \(path) is not a file")
            return
        }

        do {
            let openFile: OpenFile = try file.open(permissions: .read)
            try? openFile.close()
        } catch {
            XCTFail("Failed to open path \(path) for reading with error: \(error)")
        }
    }

    func testReadFile() {
        var _path: String?
        repeat {
            _path = OpenTests.create(.file, contents: .randomBytes(1024))
        } while (_path == nil)

        let path = _path!
        defer { OpenTests.delete(path: path) }

        guard let file = FilePath(path) else {
            XCTFail("Path \(path) is not a file")
            return
        }

        do {
            guard let contents = try file.read(encoding: .ascii) else {
                XCTFail("Failed to read contents of \(path)")
                return
            }

            // For some reason the echo doesn't always put the right number of bytes in the file?
            if contents.count != 1024 {
                return testReadFile()
            }
            XCTAssertEqual(contents, OpenTests.read(file))
        } catch {
            XCTFail("Failed to read path \(path) with error: \(error)")
        }
    }

    func testWriteFile() {
        var _path: String?
        repeat {
            _path = OpenTests.create(.file, contents: .empty)
        } while (_path == nil)

        let path = _path!
        defer { OpenTests.delete(path: path) }

        guard let file = FilePath(path) else {
            XCTFail("Path \(path) is not a file")
            return
        }

        do {
            let contents = "Hello World"
            try file.write(contents)
            XCTAssertEqual(contents, OpenTests.read(file))
        } catch {
            XCTFail("Failed to write to path \(path) with error: \(error)")
        }
    }

    func testOpenDirectory() {
        guard let dir = DirectoryPath("/tmp") else {
            XCTFail("/tmp exists and is not a directory")
            return
        }

        XCTAssertNoThrow(try dir.open())
    }

    func testGetDirectoryChildren() {
        #if os(Linux)
        guard let dir = DirectoryPath.home else {
            XCTFail("Could not get home directory")
            return
        }
        #else
        guard let dir = DirectoryPath("/tmp") else {
            XCTFail("/tmp is not a directory")
            return
        }
        #endif

        do {
            let openDir = try dir.open()
            let children = openDir.children()
            let recursiveChildren = try openDir.recursiveChildren()
            XCTAssertNotEqual(children, recursiveChildren)
        } catch {
            XCTFail("Failed to open a directory")
        }
    }

    func testOpenFileFlagsCustomStringConvertible() {
        let flags = OpenFileFlags.all

        #if os(Linux)
        let osFlags = ", dsync, sync"
        #else
        let osFlags = ", sharedLock, exclusiveLock, symlink, evtOnly"
        #endif

        XCTAssertEqual(flags.description, "OpenFileFlags(append, closeOnExec, create, directory, exclusive, noCTTY, noFollow, nonBlock, nDelay, truncate\(osFlags))")

        XCTAssertEqual(OpenFileFlags(integerLiteral: 0).description, "OpenFileFlags(none)")
    }

    func testOpenFilePermissionsCustomStringConvertible() {
        XCTAssertEqual(OpenFilePermissions.all.description, "OpenFilePermissions(read, write)")
        XCTAssertEqual(OpenFilePermissions.none.description, "OpenFilePermissions(none)")
    }

    func testOpenFileOptions() {
        let openFile: OpenFile
        do {
            openFile = try FilePath.temporary(prefix: "com.trailblazer.test.")
        } catch {
            XCTFail("Failed to generate a temporary file with error \(type(of: error)).\(error)")
            return
        }

        XCTAssertEqual(openFile.openPermissions, .readWrite)
        XCTAssertEqual(openFile.openFlags, [.create, .exclusive])
        XCTAssertNotNil(openFile.createMode)
        XCTAssertEqual(openFile.createMode!, 0o0600)

        try? openFile.delete()
    }

    func testOpenDirectoryOptions() {
        let openDirectory: OpenDirectory
        do {
            openDirectory = try DirectoryPath.temporary(prefix: "com.trailblazer.test.")
        } catch {
            XCTFail("Failed to generate a temporary file with error \(type(of: error)).\(error)")
            return
        }

        XCTAssertNil(openDirectory.openOptions)
        XCTAssertTrue(openDirectory.mayRead && openDirectory.mayWrite)
        XCTAssertTrue(openDirectory.isReadable && openDirectory.isWritable)

        try? openDirectory.delete()
    }

    func testURL() {
        let openFile: OpenFile
        do {
            openFile = try FilePath.temporary(prefix: "com.trailblazer.test.")
        } catch {
            XCTFail("Failed to generate a temporary file with error \(type(of: error)).\(error)")
            return
        }

        XCTAssertEqual(openFile.url, openFile.path.url)

        try? openFile.delete()
    }

    func testOpen() {
        let openDirectory: OpenDirectory
        do {
            openDirectory = try DirectoryPath.temporary(prefix: "com.trailblazer.test.")
        } catch {
            XCTFail("Failed to generate a temporary file with error \(type(of: error)).\(error)")
            return
        }

        XCTAssertEqual(try! openDirectory.open(), openDirectory)

        try? openDirectory.delete()
    }

    func testHashable() {
        let openFile1: OpenFile
        let openFile2: OpenFile
        do {
            openFile1 = try FilePath.temporary(prefix: "com.trailblazer.test.")
            let otherFile = FilePath(openFile1.path)
            openFile2 = try otherFile.open(permissions: .read, flags: .none)
        } catch {
            XCTFail("Failed to generate a temporary file with error \(type(of: error)).\(error)")
            return
        }

        XCTAssertNotEqual(openFile1, openFile2)
        XCTAssertNotEqual(openFile1.hashValue, openFile2.hashValue)
    }
}

func randomString(length: UInt) -> String {
    var chars: [CChar] = []

    while chars.count < length {
        // ASCII chars are 1 byte and the printable character range is 32-126
        // (94 chars). This will select a random ASCII character to add to the
        // string, ignoring single quotes since that's what I use to
        // encapsulate the string I'm echoing into the test file
        let char = CChar(Int.random(in: 32...126))

        // No single quotes
        guard char != 39 else { continue }

        chars.append(char)
    }

    return chars.withUnsafeBufferPointer { ptr in
        return String(cString: ptr.baseAddress!, encoding: .ascii)!
    }
}
