import Foundation
import SwiftShell
@testable import TrailBlazer
import XCTest

class OpenTests: XCTestCase {
    enum Content {
        case randomBytes(UInt)
        case repeatedBytes(CChar, UInt)
        case string([CChar])
        indirect case files(with: Content)

        static let empty: Content = .randomBytes(0)
    }

    static func create(_ type: PathType, contents: Content) -> String? {
        guard let home = DirectoryPath.home else {
            fatalError("Failed to get home directory")
        }
        let path = (home + "\(UUID()).test")._path

        switch type {
        case .file:
            let output = SwiftShell.run(bash: "touch \(path)")
            guard output.succeeded else { return nil }
            switch contents {
            case .randomBytes(let size):
                if size > 0 {
                    let cmd = SwiftShell.run(bash: "echo -n '\(randomString(length: size))' > \(path)")
                    guard cmd.succeeded else {
                        OpenTests.delete(path: path)
                        return nil
                    }
                }
            case .repeatedBytes(let char, let size):
                var chars: [CChar] = []
                while chars.count < size {
                    chars.append(char)
                }
                let str = chars.withUnsafeBufferPointer { ptr in
                    String(cString: ptr.baseAddress!, encoding: .ascii)!
                }

                guard SwiftShell.run(bash: "echo \(str) >> \(path)").succeeded else {
                    OpenTests.delete(path: path)
                    return nil
                }
            case .string(let chars):
                let str = chars.withUnsafeBufferPointer { ptr in
                    String(cString: ptr.baseAddress!, encoding: .ascii)!
                }

                guard SwiftShell.run(bash: "echo \(str) >> \(path)").succeeded else {
                    OpenTests.delete(path: path)
                    return nil
                }
            default:
                OpenTests.delete(path: path)
                return nil
            }

            return path
        case .directory: return path
        default: return nil
        }
    }

    @discardableResult
    static func delete(path: String) -> Bool {
        return SwiftShell.run(bash: "rm -rf \(path)").succeeded
    }

    static func read(_ file: FilePath, bytes: Int) -> String {
        let contents = SwiftShell.run(bash: "cat \(file._path)").stdout
        guard contents.count >= bytes else { return contents }
        return String(contents[..<contents.index(contents.startIndex, offsetBy: bytes)])
    }

    func testOpenFile() {
        var _path: String?
        repeat {
            _path = OpenTests.create(.file, contents: .empty)
        } while _path == nil

        let path = _path!
        defer { OpenTests.delete(path: path) }

        guard let file = FilePath(path) else {
            XCTFail("Path \(path) is not a file")
            return
        }

        do {
            _ = try file.open(mode: .read)
        } catch {
            XCTFail("Failed to open path \(path) for reading with error: \(error)")
        }
    }

    func testReadFile() {
        var _path: String?
        repeat {
            _path = OpenTests.create(.file, contents: .randomBytes(1024))
        } while _path == nil

        let path = _path!
        defer { OpenTests.delete(path: path) }

        guard var file = FilePath(path) else {
            XCTFail("Path \(path) is not a file")
            return
        }

        do {
            guard let contents = try file.read(encoding: .ascii) else {
                XCTFail("Failed to read contents of \(path)")
                return
            }

            // For some reason the echo doesn't always put the right number of bytes in the file?
            if contents.count != 1024 {
                return testReadFile()
            }
            XCTAssertEqual(contents, OpenTests.read(file, bytes: 1024))
        } catch {
            XCTFail("Failed to read path \(path) with error: \(error)")
        }

        try? file.delete()
    }

    func testReadDifferentBuffersFile() {
        var _path: String?
        repeat {
            _path = OpenTests.create(.file, contents: .repeatedBytes(CChar(97), 1024))
        } while _path == nil

        let path = _path!
        defer { OpenTests.delete(path: path) }

        let openFile: FileStream
        do {
            openFile = try FilePath(path)!.open(mode: .read)
        } catch {
            XCTFail("Failed to open the file for reading")
            return
        }

        do {
            var contents: String = try openFile.read(bytes: 64, encoding: .ascii)!
            contents += try openFile.read(bytes: 128, encoding: .ascii)!
            contents += try openFile.read(bytes: 256, encoding: .ascii)!
            contents += try openFile.read(bytes: 512, encoding: .ascii)!
            contents += try openFile.read(bytes: 64, encoding: .ascii)!

            XCTAssertEqual(contents, OpenTests.read(openFile.path, bytes: 1024))
        } catch {
            XCTFail("Failed to read path \(path) with error: \(error)")
        }

        var fpath = openFile.path
        try? fpath.delete()
    }

    func testWriteFile() {
        var _path: String?
        repeat {
            _path = OpenTests.create(.file, contents: .empty)
        } while _path == nil

        let path = _path!
        defer { OpenTests.delete(path: path) }

        guard let file = FilePath(path) else {
            XCTFail("Path \(path) is not a file")
            return
        }

        do {
            let contents = "Hello World"
            try file.write(contents)
            XCTAssertEqual(contents, OpenTests.read(file, bytes: contents.count))
        } catch {
            XCTFail("Failed to write to path \(path) with error: \(error)")
        }
    }

    func testReadThenWrite() {
        let openFile: FileStream
        do {
            openFile = try FilePath.temporary(prefix: "com.trailblazer.test.").path.open(mode: .read)
        } catch {
            XCTFail("Failed to open the temporary path for reading")
            return
        }

        XCTAssertThrowsError(try openFile.write("Hello world"))
        var file = openFile.path
        try? file.delete()
    }

    func testWriteThenRead() {
        let openFile: FileStream
        do {
            openFile = try FilePath.temporary(prefix: "com.trailblazer.test.").path.open(mode: .write)
            try openFile.write("Hello world")
        } catch {
            XCTFail("Failed to open the temporary path for writing with error \(type(of: error)).\(error)")
            return
        }

        XCTAssertThrowsError(try openFile.read())
        var file = openFile.path
        try? file.delete()
    }

    func testGetCharacter() {
        let openFile: FileStream
        do {
            openFile = try FilePath.temporary(prefix: "com.trailblazer.test.").path.open(mode: "w+")
            try openFile.write("Hello world")
        } catch {
            XCTFail("Failed to open the temporary path for writing with error \(type(of: error)).\(error)")
            return
        }

        XCTAssertNoThrow(try openFile.rewind())

        do {
            let char = try openFile.nextCharacter()
            XCTAssertEqual(char, Character("H"))
        } catch {
            XCTFail("Failed to get next character with error: \(type(of: error)).\(error)")
        }

        var file = openFile.path
        try? file.delete()
    }

    func testUngetCharacter() {
        let openFile: FileStream
        do {
            openFile = try FilePath.temporary(prefix: "com.trailblazer.test.").path.open(mode: "w+")
            try openFile.write("Hello world")
        } catch {
            XCTFail("Failed to open the temporary path for writing with error \(type(of: error)).\(error)")
            return
        }

        XCTAssertNoThrow(try openFile.rewind())

        do {
            var char = try openFile.nextCharacter()
            XCTAssertEqual(char, Character("H"))
            char = try openFile.nextCharacter()
            XCTAssertEqual(char, Character("e"))
            XCTAssertNoThrow(try openFile.ungetCharacter(char))
            char = try openFile.nextCharacter()
            XCTAssertEqual(char, Character("e"))
        } catch {
            XCTFail("Failed to get next character with error: \(type(of: error)).\(error)")
        }

        var file = openFile.path
        try? file.delete()
    }

    func testOpenDirectory() {
        guard let dir = DirectoryPath("/tmp") else {
            XCTFail("/tmp exists and is not a directory")
            return
        }

        XCTAssertNoThrow(try dir.open())
    }

    func testGetDirectoryChildren() {
        #if os(Linux)
        guard let dir = DirectoryPath.home else {
            XCTFail("Could not get home directory")
            return
        }
        #else
        guard let dir = DirectoryPath("/tmp") else {
            XCTFail("/tmp is not a directory")
            return
        }
        #endif

        do {
            let openDir = try dir.open()
            let children = openDir.children()
            let recursiveChildren = try openDir.recursiveChildren(depth: 2, options: .includeHidden)
            XCTAssertNotEqual(children, recursiveChildren)
        } catch {
            XCTFail("Failed to open a directory with error \(type(of: error)).\(error)")
        }
    }

    func testOpenFileModeCustomStringConvertible() {
        XCTAssertEqual(OpenFileMode.read.description, "OpenFileMode(r)")
        XCTAssertEqual(OpenFileMode.readPlus.description, "OpenFileMode(r+)")

        XCTAssertEqual(OpenFileMode.write.description, "OpenFileMode(w)")
        XCTAssertEqual(OpenFileMode.writePlus.description, "OpenFileMode(w+)")

        XCTAssertEqual(OpenFileMode.append.description, "OpenFileMode(a)")
        XCTAssertEqual(OpenFileMode.appendPlus.description, "OpenFileMode(a+)")

        var mode: OpenFileMode = [.read, .binary]
        XCTAssertEqual(mode.description, "OpenFileMode(rb)")
        mode = [.readPlus, .binary]
        XCTAssertEqual(mode.description, "OpenFileMode(r+b)")

        mode = [.write, .binary]
        XCTAssertEqual(mode.description, "OpenFileMode(wb)")
        mode = [.writePlus, .binary]
        XCTAssertEqual(mode.description, "OpenFileMode(w+b)")

        mode = [.append, .binary]
        XCTAssertEqual(mode.description, "OpenFileMode(ab)")
        mode = [.appendPlus, .binary]
        XCTAssertEqual(mode.description, "OpenFileMode(a+b)")
    }

    func testOpenFileOptions() {
        let openFile: FileStream
        do {
            openFile = try FilePath.temporary(prefix: "com.trailblazer.test.")
        } catch {
            XCTFail("Failed to generate a temporary file with error \(type(of: error)).\(error)")
            return
        }

        XCTAssertEqual(openFile.openMode, .readPlus)
        XCTAssertEqual(openFile.permissions, 0o0600)

        var file = openFile.path
        try? file.delete()
    }

    func testOpenDirectoryOptions() {
        let openDirectory: OpenDirectory
        do {
            openDirectory = try DirectoryPath.temporary(prefix: "com.trailblazer.test.")
        } catch {
            XCTFail("Failed to generate a temporary file with error \(type(of: error)).\(error)")
            return
        }

        XCTAssertEqual(openDirectory.openOptions, .default)
        XCTAssertTrue(openDirectory.isReadable && openDirectory.isWritable)

        var dir = openDirectory.path
        try? dir.delete()
    }

    func testURL() {
        let openFile: FileStream
        do {
            openFile = try FilePath.temporary(prefix: "com.trailblazer.test.")
        } catch {
            XCTFail("Failed to generate a temporary file with error \(type(of: error)).\(error)")
            return
        }

        XCTAssertEqual(openFile.url, openFile.path.url)

        var file = openFile.path
        try? file.delete()
    }

    func testSeek() {
        let openFile: FileStream
        do {
            openFile = try FilePath.temporary(prefix: "com.trailblazer.test.")
            try openFile.write("Hello World")
        } catch {
            XCTFail("Failed to generate/write to a temporary file with error \(type(of: error)).\(error)")
            return
        }

        XCTAssertNotEqual(0, openFile.offset)
        XCTAssertNoThrow(try openFile.rewind())
        XCTAssertEqual(0, openFile.offset)

        XCTAssertNoThrow(try openFile.seek(fromEnd: -6))
        XCTAssertEqual(openFile.offset, openFile.size - 6)

        // This cannot be openFile += 11 or else it deinitializes the openFile, causing issues
        openFile.offset = openFile.offset + 11
        XCTAssertEqual(openFile.offset, openFile.size - 6 + 11)

        #if os(macOS)
        try! openFile.rewind()

        // I'm not familiar with these kinds of seeking or how to properly set
        // them up for testing
        try? openFile.seek(toNextHoleAfter: 0)
        try? openFile.seek(toNextDataAfter: openFile.offset)
        #endif

        var file = openFile.path
        try? file.delete()
    }

    func testSeekReadWrite() {
        let openFile: FileStream
        do {
            openFile = try FilePath.temporary(prefix: "com.trailblazer.test.")
            try openFile.write("Hello World")
        } catch {
            XCTFail("Failed to generate/write to a temporary file with error \(type(of: error)).\(error)")
            return
        }

        XCTAssertNoThrow(try openFile.write("Jacob", at: Offset(type: .beginning, bytes: 6)))
        XCTAssertEqual(try! openFile.read(from: Offset(type: .beginning, bytes: 6)), "Jacob")

        var file = openFile.path
        try? file.delete()
    }

    func testSeekStatic() {
        let openFile: FileStream
        do {
            openFile = try FilePath.temporary(prefix: "com.trailblazer.test.")
            try openFile.write("Hello World")
        } catch {
            XCTFail("Failed to generate/write to a temporary file with error \(type(of: error)).\(error)")
            return
        }

        XCTAssertNotEqual(0, openFile.offset)
        XCTAssertNoThrow(try FilePath.rewind(in: openFile))
        XCTAssertEqual(0, openFile.offset)

        XCTAssertNoThrow(try FilePath.seek(Offset(.end, -6), in: openFile))
        XCTAssertEqual(openFile.offset, openFile.size - 6)

        #if os(macOS)
        try! openFile.rewind()

        // I'm not familiar with these kinds of seeking or how to properly set
        // them up for testing
        try? FilePath.seek(Offset(.hole, 0), in: openFile)
        try? FilePath.seek(Offset(.data, openFile.offset), in: openFile)
        #endif

        var file = openFile.path
        try? file.delete()
    }

    func testSeekStaticReadWrite() {
        let openFile: FileStream
        do {
            openFile = try FilePath.temporary(prefix: "com.trailblazer.test.")
            try FilePath.write("Hello World", to: openFile)
        } catch {
            XCTFail("Failed to generate/write to a temporary file with error \(type(of: error)).\(error)")
            return
        }

        XCTAssertNoThrow(try FilePath.write("Jacob", at: Offset(type: .beginning, bytes: 6), to: openFile))
        XCTAssertEqual(try! FilePath.read(from: Offset(type: .beginning, bytes: 6), from: openFile), "Jacob")

        var file = openFile.path
        try? file.delete()
    }

    func testHashable() {
        let openFile1: FileStream
        let openFile2: FileStream
        do {
            openFile1 = try FilePath.temporary(prefix: "com.trailblazer.test.")
            let otherFile = FilePath(openFile1.path)
            openFile2 = try otherFile.open(mode: .read)
        } catch {
            XCTFail("Failed to generate a temporary file with error \(type(of: error)).\(error)")
            return
        }

        XCTAssertNotEqual(openFile1, openFile2)
        XCTAssertNotEqual(openFile1.hashValue, openFile2.hashValue)

        var file = openFile1.path
        try? file.delete()
    }

    func testCustomStringConvertible() {
        do {
            let openFile = try FilePath.temporary(prefix: "com.trailblazer.test.")
            XCTAssertEqual(openFile.description, "Open<FilePath>(path: \(openFile.path), options: OpenOptions(mode: OpenFileMode(r+)))")
            var file = openFile.path
            try? file.delete()
        } catch {
            XCTFail("Failed to generate a temporary file")
        }
    }

    func testOpenFileClosure() {
        var _path: String?
        repeat {
            _path = OpenTests.create(.file, contents: .empty)
        } while _path == nil

        let path = _path!
        defer { OpenTests.delete(path: path) }

        guard let file = FilePath(path) else {
            XCTFail("Path \(path) is not a file")
            return
        }

        do {
            try file.open(options: FilePath.OpenOptions(mode: .readPlus)) { openFile in
                XCTAssertNoThrow(try openFile.write("Hello world"))
                XCTAssertEqual(try! openFile.read(from: .beginning), "Hello world")
            }

            try file.open(mode: .writePlus) { openFile in
                XCTAssertNoThrow(try openFile.write("Hello world"))
                XCTAssertEqual(try! openFile.read(from: .beginning), "Hello world")
            }
        } catch {
            XCTFail("Failed to open path \(path) for reading and writing with error: \(error)")
        }
    }

    func testOpenDirectoryClosure() {
        guard let dir = DirectoryPath("/tmp") else {
            XCTFail("/tmp is not a directory")
            return
        }

        XCTAssertNoThrow(try dir.open { _ in })
    }
}

func randomString(length: UInt) -> String {
    var chars: [CChar] = []

    while chars.count < length {
        // ASCII chars are 1 byte and the printable character range is 32-126
        // (94 chars). This will select a random ASCII character to add to the
        // string, ignoring single quotes since that's what I use to
        // encapsulate the string I'm echoing into the test file
        let char = CChar(Int.random(in: 32...126))

        // No single quotes
        guard char != 39 else { continue }

        chars.append(char)
    }

    return chars.withUnsafeBufferPointer { ptr in
        String(cString: ptr.baseAddress!, encoding: .ascii)!
    }
}
