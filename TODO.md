# To Do
- FilePath
  - [x] Create new files
    - [x] Create intermediate directories
    - [x] With specified contents
  - [x] Investigate if using stdio(3) operations instead of directly interacting with an open file descriptor would simplify usage
  - [ ] Scanning and delimitting reads
    - [ ] fscanf(3)
      - [ ] FileScanner?
    - [ ] getdelim(3)
- DirectoryPath
  - [x] Get directory contents
  - [x] Get directory contents recursively
    - [x] Eagerly
    - [ ] Lazily
  - [x] Create new directories
    - [x] Create intermediate directories
  - [x] Delete directories
  - [x] Recursively delete directory
- GenericPath (AKA all Paths)
  - [x] Change path ownership
  - [x] Change path permissions
    - [x] Allow octal numeric strings to be used for changing permissions
  - [x] Move paths
  - [x] Rename paths (move alias)
  - [x] URL conversion
  - [x] Get/generate temporary files/directories
  - [x] Copy paths
  - [ ] Initialize from URLs
- TemporaryPaths
  - [x] Temporary path in closure (deleted afterwards)
  - [x] Base: Whether to generate or supply the root temporary directory
- OpenPaths
  - [x] Open only for closure
- Misc. Additions
  - [x] Globbing
  - [x] LinkedPath (symlinks and hard links)
  - [x] Make Paths Codable
  - [x] APIs for checking permissions to a path
    - [x] canRead/Write/Execute/Delete == Whether or not the calling process (or specified uid/gid/username/groupname) can read/write/execute/delete the path
    - [x] mayRead/Write == Whether or not the path was opened with read/write permissions
  - [x] SocketPath
  - [ ] FIFOPath?
  - [ ] BlockPath?
  - [x] CharacterPath
  - [ ] Place deleted items in trash (instead of deleting directly)
  - [x] Change CWD for closure only
  - [ ] Pattern matching (~=)
  - [ ] Useful operators (<<, >>, etc)
  - [x] Consolidate repeated/common errors
  - [ ] Atomic writing (see Data.WritingOptions)
  - [ ] Make sure we support common Data.ReadingOptions
- [ ] Investigate TypeErasure to see if it could benefit Paths and Open objects interact together more nicely
- [ ] Investigate ARC best-practices and see if memory usage/performance/correctness can be improved
  - https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html
- [x] Investigate improved Hashable conformances
  - https://developer.apple.com/documentation/swift/adopting_common_protocols
- [ ] Study the Ownership Manifesto to see if anything can have improved memory semantics/performance
  - https://github.com/apple/swift/blob/master/docs/OwnershipManifesto.md
- [ ] Investiagte class behaviors and ensure proper COW (or other) copy semantics
- [ ] Slicing/Collection APIs
  - [x] Sequence conformance
  - [ ] Slicing
  - [ ] Joining Slices
- [ ] Migrate usage examples to a separate Wiki
  - [ ] Document performance pitfalls
- [ ] Make a FileSystem utility for easily getting some file system attributes
  - [ ] Free/Used bytes
  - [ ] Total size
  - [ ] Type
  - [ ] More?
- [ ] Annotate code with preconditions and assertions
- Investigate Domains
  - https://developer.apple.com/documentation/foundation/filemanager/searchpathdomainmask
    - [ ] User (~)
    - [ ] System (/)
    - [ ] Local (/usr/local)
    - [ ] Network (??)
    - [ ] All
- Investigate Common Search Paths
  - https://developer.apple.com/documentation/foundation/filemanager/searchpathdirectory
- [x] Rebrand as PathMan
  - [ ] Awesome logo/icon
- Crazy Stuff
  - [ ] `URLPath`
    - [ ] Separate current `Path` protocol into a `FileSystemPath` sub-protocol (only keeping relevant stuff in `Path`)
    - [ ] Opening a `URLPath` downloads data?
    - [ ] Support relevant standards and common manipulations
- [ ] Validate code meets possible optimization points:
  - https://github.com/apple/swift/blob/master/docs/OptimizationTips.rst
- [ ] Use more C-standard APIs to move away from only POSIX specific APIs (in preparation for Windows support)
